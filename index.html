<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Art Studio Pro</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1b26;
            color: #a9b1d6;
            overflow: hidden;
            touch-action: none; 
        }
        .font-pixel { font-family: 'Press Start 2P', cursive; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1a1b26; }
        ::-webkit-scrollbar-thumb { background: #414868; border-radius: 3px; }
        
        .checkered-bg {
            background-image: 
                linear-gradient(45deg, #2a2b36 25%, transparent 25%), 
                linear-gradient(-45deg, #2a2b36 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #2a2b36 75%), 
                linear-gradient(-45deg, transparent 75%, #2a2b36 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas { image-rendering: pixelated; }
        .layer-item.active { background-color: #3b82f6; color: white; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        // --- ICONS (SVG) ---
        const Icon = ({ path, size = 20, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {path}
            </svg>
        );

        const Save = (p) => <Icon {...p} path={<><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></>} />;
        const Trash2 = (p) => <Icon {...p} path={<><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></>} />;
        const Copy = (p) => <Icon {...p} path={<><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></>} />;
        const RefreshCw = (p) => <Icon {...p} path={<><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></>} />;
        const PaletteIcon = (p) => <Icon {...p} path={<><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></>} />;
        const Sliders = (p) => <Icon {...p} path={<><line x1="4" y1="21" x2="4" y2="14"/><line x1="4" y1="10" x2="4" y2="3"/><line x1="12" y1="21" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="3"/><line x1="20" y1="21" x2="20" y2="16"/><line x1="20" y1="12" x2="20" y2="3"/><line x1="1" y1="14" x2="7" y2="14"/><line x1="9" y1="8" x2="15" y2="8"/><line x1="17" y1="16" x2="23" y2="16"/></>} />;
        const LayersIcon = (p) => <Icon {...p} path={<><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></>} />;
        const Eye = (p) => <Icon {...p} path={<><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></>} />;
        const EyeOff = (p) => <Icon {...p} path={<><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></>} />;
        const Plus = (p) => <Icon {...p} path={<><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></>} />;
        const Minus = (p) => <Icon {...p} path={<line x1="5" y1="12" x2="19" y2="12"/>} />;
        const ImageIcon = (p) => <Icon {...p} path={<><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></>} />;
        const ArrowRight = (p) => <Icon {...p} path={<><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></>} />;
        const ZoomIn = (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></>} />;
        const ZoomOut = (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></>} />;
        const ScanEye = (p) => <Icon {...p} path={<><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><circle cx="12" cy="12" r="3"/><path d="M12 16a4 4 0 0 1 0-8"/></>} />;
        const Wand2 = (p) => <Icon {...p} path={<><path d="m19 2 2 2-2 2-2-2 2-2Z"/><path d="m5 7 2 2-2 2-2-2 2-2Z"/><path d="m15 11 2 2-2 2-2-2 2-2Z"/><path d="M6 13l5.55-5.55a2.1 2.1 0 0 1 2.95 0l5.55 5.55a2.1 2.1 0 0 1 0 2.95l-8 8a2.1 2.1 0 0 1-2.95 0L6 15.95a2.1 2.1 0 0 1 0-2.95Z"/></>} />;

        const PenTool = (p) => <Icon {...p} path={<><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></>} />;
        const Pencil = (p) => <Icon {...p} path={<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>} />;
        const Eraser = (p) => <Icon {...p} path={<><path d="M20 20.5H6.8a2.8 2.8 0 0 1-2-2.8V6.8a2.8 2.8 0 0 1 2.8-2.8h8.4"/><path d="M14 2L2 14l10 10 12-12-10-10z"/></>} />;
        const Droplet = (p) => <Icon {...p} path={<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>} />; 
        const PaintBucket = (p) => <Icon {...p} path={<><path d="M19 11L12 17l-7-7"/><path d="M19 11l-5-5-2 2 5 5 2-2z"/><path d="M5 4l7 7 2-2-7-7-2 2z"/><path d="M2 20a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2"/></>} />;
        const Download = (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></>} />;
        const GridIcon = (p) => <Icon {...p} path={<><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></>} />;
        const Undo = (p) => <Icon {...p} path={<><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></>} />;

        // --- UTILS ---
        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        function hexToHSL(H) {
            let r=0,g=0,b=0;
            if(H.length==4){r="0x"+H[1]+H[1];g="0x"+H[2]+H[2];b="0x"+H[3]+H[3];}
            else if(H.length==7){r="0x"+H[1]+H[2];g="0x"+H[3]+H[4];b="0x"+H[5]+H[6];}
            r/=255;g/=255;b/=255;
            let cmin=Math.min(r,g,b),cmax=Math.max(r,g,b),delta=cmax-cmin,h=0,s=0,l=0;
            if(delta==0)h=0;else if(cmax==r)h=((g-b)/delta)%6;else if(cmax==g)h=(b-r)/delta+2;else h=(r-g)/delta+4;
            h=Math.round(h*60);if(h<0)h+=360;l=(cmax+cmin)/2;s=delta==0?0:delta/(1-Math.abs(2*l-1));
            return {h, s:+(s*100).toFixed(1), l:+(l*100).toFixed(1)};
        }
        function hslToHex(h,s,l) {
            s/=100;l/=100;let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs(((h/60)%2)-1)),m=l-c/2,r=0,g=0,b=0;
            if(0<=h&&h<60){r=c;g=x;b=0;}else if(60<=h&&h<120){r=x;g=c;b=0;}else if(120<=h&&h<180){r=0;g=c;b=x;}else if(180<=h&&h<240){r=0;g=x;b=c;}else if(240<=h&&h<300){r=x;g=0;b=c;}else if(300<=h&&h<360){r=c;g=0;b=x;}
            r=Math.round((r+m)*255).toString(16);g=Math.round((g+m)*255).toString(16);b=Math.round((b+m)*255).toString(16);
            return "#"+(r.length==1?"0"+r:r)+(g.length==1?"0"+g:g)+(b.length==1?"0"+b:b);
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        // Improved Color Distance (Redmean)
        function colorDist(c1, c2) {
            if(!c1 || !c2) return Infinity;
            let rmean = (c1[0] + c2[0]) / 2;
            let r = c1[0] - c2[0];
            let g = c1[1] - c2[1];
            let b = c1[2] - c2[2];
            return Math.sqrt((((512+rmean)*r*r)>>8) + 4*g*g + (((767-rmean)*b*b)>>8));
        }

        // --- SUB-COMPONENTS ---

        const PaletteGenerator = ({ savedPalettes, setSavedPalettes, onSelectColor }) => {
            const [baseColor, setBaseColor] = useState('#3b82f6');
            const [steps, setSteps] = useState(5);
            const [contrast, setContrast] = useState(15);
            const [hueShift, setHueShift] = useState(10);
            const [satShift, setSatShift] = useState(10);

            const palette = useMemo(() => {
                const { h: baseH, s: baseS, l: baseL } = hexToHSL(baseColor);
                const colors = [];
                const midPoint = (steps - 1) / 2;
                for (let i = 0; i < steps; i++) {
                    const offset = i - midPoint;
                    let h = (baseH + (offset * hueShift)) % 360; if(h<0)h+=360;
                    let s = Math.max(0, Math.min(100, baseS + (offset * satShift * -0.5)));
                    let l = Math.max(0, Math.min(100, baseL + (offset * contrast)));
                    colors.push(hslToHex(h, s, l));
                }
                return colors;
            }, [baseColor, steps, contrast, hueShift, satShift]);

            const copyToClipboard = (text) => {
                const ta = document.createElement("textarea"); ta.value=text; ta.style.position="fixed"; ta.style.left="-9999px";
                document.body.appendChild(ta); ta.focus(); ta.select(); try{ document.execCommand('copy'); } catch(e){} document.body.removeChild(ta);
            };

            return (
                <div className="flex flex-col h-full overflow-y-auto p-4 md:p-8 gap-8">
                    <div className="flex flex-col lg:flex-row gap-8">
                        <div className="lg:w-1/3 space-y-6">
                            <div className="bg-[#1f2937] p-5 rounded-2xl border border-gray-700 shadow-xl">
                                <label className="block text-gray-400 text-xs font-bold uppercase mb-3">Màu Chủ Đạo</label>
                                <div className="flex gap-4">
                                    <div className="relative w-24 h-24 rounded-2xl overflow-hidden ring-4 ring-gray-600 shrink-0">
                                        <input type="color" value={baseColor} onChange={(e)=>setBaseColor(e.target.value)} className="absolute -top-8 -left-8 w-40 h-40 cursor-pointer"/>
                                    </div>
                                    <div className="flex-1 flex flex-col justify-center gap-2">
                                        <input type="text" value={baseColor.toUpperCase()} onChange={(e)=>setBaseColor(e.target.value)} className="w-full bg-gray-900 border border-gray-700 rounded-xl px-4 py-3 text-white font-mono text-xl focus:outline-none focus:border-blue-500 uppercase"/>
                                        <button onClick={()=>setBaseColor('#'+Math.floor(Math.random()*16777215).toString(16))} className="text-xs text-blue-400 hover:underline flex items-center gap-1"><RefreshCw size={12}/> Random Color</button>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="bg-[#1f2937] p-5 rounded-2xl border border-gray-700 shadow-xl space-y-4">
                                <div>
                                    <div className="flex justify-between text-xs mb-1"><span className="text-gray-400">Steps</span><span className="text-blue-400 font-bold">{steps}</span></div>
                                    <input type="range" min="2" max="32" value={steps} onChange={(e)=>setSteps(Number(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"/>
                                </div>
                                <div>
                                    <div className="flex justify-between text-xs mb-1"><span className="text-gray-400">Contrast</span><span className="text-yellow-400 font-bold">{contrast}%</span></div>
                                    <input type="range" min="5" max="30" value={contrast} onChange={(e)=>setContrast(Number(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"/>
                                </div>
                                <div>
                                    <div className="flex justify-between text-xs mb-1"><span className="text-gray-400">Hue Shift</span><span className="text-purple-400 font-bold">{hueShift}°</span></div>
                                    <input type="range" min="0" max="60" value={hueShift} onChange={(e)=>setHueShift(Number(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-purple-500"/>
                                </div>
                                <div>
                                    <div className="flex justify-between text-xs mb-1"><span className="text-gray-400">Saturation Shift</span><span className="text-green-400 font-bold">{satShift}%</span></div>
                                    <input type="range" min="-20" max="20" value={satShift} onChange={(e)=>setSatShift(Number(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-green-500"/>
                                </div>
                            </div>
                        </div>

                        <div className="lg:w-2/3 flex flex-col gap-6">
                            <div className="bg-[#1f2937] p-6 rounded-3xl border border-gray-700 shadow-2xl flex flex-col items-center">
                                <div className="flex w-full rounded-2xl overflow-hidden shadow-lg h-32 md:h-40 ring-4 ring-gray-800">
                                    {palette.map((c, i) => (
                                        <div key={i} className="flex-1 color-swatch cursor-pointer group relative" style={{backgroundColor:c}} 
                                            onClick={()=>{copyToClipboard(c); onSelectColor(c);}} title="Click: Copy & Use">
                                            <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition bg-black/20 text-white font-mono text-xs md:text-sm backdrop-blur-sm">{c}</div>
                                        </div>
                                    ))}
                                </div>
                                <div className="mt-6 flex flex-wrap gap-2 justify-center">
                                    {palette.map((c, i) => (
                                        <div key={i} className="flex flex-col items-center gap-1" onClick={()=>onSelectColor(c)}>
                                            <div className="w-8 h-8 rounded border border-gray-600 cursor-pointer" style={{backgroundColor:c}}></div>
                                            <span className="text-[10px] text-gray-500 font-mono uppercase">{c}</span>
                                        </div>
                                    ))}
                                </div>
                                <button onClick={()=>{setSavedPalettes([{id:Date.now(), colors:palette, base:baseColor}, ...savedPalettes])}} className="mt-6 bg-green-600 hover:bg-green-500 text-white px-6 py-2 rounded-xl font-bold flex items-center gap-2 shadow-lg transition">
                                    <Save size={18}/> Lưu Bảng Màu
                                </button>
                            </div>

                            {savedPalettes.length > 0 && (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {savedPalettes.map(p => (
                                        <div key={p.id} className="bg-[#1f2937] p-3 rounded-xl border border-gray-700 hover:border-gray-500 transition">
                                            <div className="flex h-8 rounded overflow-hidden mb-2 ring-1 ring-gray-600">
                                                {p.colors.map((c,i)=><div key={i} className="flex-1 cursor-pointer" style={{backgroundColor:c}} onClick={()=>onSelectColor(c)}></div>)}
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <span className="text-xs text-gray-500 font-mono">{p.base}</span>
                                                <button onClick={()=>{if(confirm('Xóa?')) setSavedPalettes(savedPalettes.filter(x=>x.id!==p.id))}} className="text-gray-600 hover:text-red-500"><Trash2 size={14}/></button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Image Converter Tab
        const PixelConverter = ({ onSendToEditor, savedPalettes, setSavedPalettes }) => {
            const [srcImage, setSrcImage] = useState(null);
            const [width, setWidth] = useState(64);
            
            // Smart Mode Params
            const [baseColorCount, setBaseColorCount] = useState(6); 
            const [shadesPerColor, setShadesPerColor] = useState(6); 

            const [colorDepth, setColorDepth] = useState(8); 
            const [conversionMode, setConversionMode] = useState('smart'); 
            const [ditherMode, setDitherMode] = useState('none'); 
            const [contrast, setContrast] = useState(0); 
            const [edgeThreshold, setEdgeThreshold] = useState(40);
            const [cleanupLevel, setCleanupLevel] = useState(1); // Default Low
            const [autoEnhance, setAutoEnhance] = useState(true); // NEW: Auto Enhance
            
            const [outlineMode, setOutlineMode] = useState('silhouette'); 
            const [outlineColorMode, setOutlineColorMode] = useState('darker'); 
            
            const [previewUrl, setPreviewUrl] = useState(null);
            const [combinedUrl, setCombinedUrl] = useState(null); 
            const [previewScale, setPreviewScale] = useState(1);
            
            const canvasRef = useRef(null);

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image();
                        img.onload = () => setSrcImage(img);
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            // Helpers
            const applyContrast = (color, factor) => Math.max(0, Math.min(255, factor * (color - 128) + 128));
            const darkenColor = (r, g, b, amount=0.4) => [Math.floor(r*amount), Math.floor(g*amount), Math.floor(b*amount)];

            const findClosest = (r, g, b, palette) => {
                if (!palette || palette.length === 0) return [r, g, b];
                let min = Infinity, best = palette[0] || [r,g,b];
                for(let c of palette) {
                    if(!c) continue;
                    // REDMEAN Distance
                    const d = colorDist([r,g,b], c);
                    if(d < min) { min = d; best = c; }
                }
                return best;
            };

             const generateRampFromColor = (rgb, steps) => {
                const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
                const { h, s, l } = hexToHSL(hex); 
                const colors = [];
                const midPoint = (steps - 1) / 2;
                const hueShift = 10;
                const satShift = 10;
                const contrast = 15;
                for (let i = 0; i < steps; i++) {
                    const offset = i - midPoint;
                    let hNew = (h + (offset * hueShift)) % 360; if(hNew<0)hNew+=360;
                    let sNew = Math.max(0, Math.min(100, s + (offset * satShift * -0.5)));
                    let lNew = Math.max(0, Math.min(100, l + (offset * contrast)));
                    const hexRes = hslToHex(hNew, sNew, lNew);
                    const rgbRes = hexToRgb(hexRes);
                    if(rgbRes) colors.push([rgbRes.r, rgbRes.g, rgbRes.b]);
                }
                return colors;
            };

            const generateSmartPalette = (imageData, k, shades) => {
                const pixels = [];
                for(let i=0; i<imageData.data.length; i+=16) { 
                    if(imageData.data[i+3] > 128) pixels.push([imageData.data[i], imageData.data[i+1], imageData.data[i+2]]);
                }
                if(pixels.length === 0) return [[0,0,0]];
                let centroids = [];
                for(let i=0; i<k; i++) centroids.push(pixels[Math.floor(Math.random()*pixels.length)] || [0,0,0]);
                for(let iter=0; iter<3; iter++) {
                    const clusters = Array(k).fill().map(()=>[]);
                    pixels.forEach(p => {
                        let minDist = Infinity, closeIdx = 0;
                        centroids.forEach((c, i) => {
                            if(!c) return;
                            const d = colorDist(p, c); // Uses Redmean
                            if(d < minDist) { minDist = d; closeIdx = i; }
                        });
                        clusters[closeIdx].push(p);
                    });
                    centroids = centroids.map((c, i) => {
                        if(clusters[i].length === 0) return c;
                        const r = Math.round(clusters[i].reduce((s, p) => s + p[0], 0) / clusters[i].length);
                        const g = Math.round(clusters[i].reduce((s, p) => s + p[1], 0) / clusters[i].length);
                        const b = Math.round(clusters[i].reduce((s, p) => s + p[2], 0) / clusters[i].length);
                        return [r,g,b];
                    });
                }
                let fullPalette = [];
                centroids.forEach(c => {
                    if(c) {
                        const ramp = generateRampFromColor(c, shades);
                        fullPalette = [...fullPalette, ...ramp];
                    }
                });
                return fullPalette;
            };

            // SMART CLEANUP (Orphan removal)
            const cleanNoise = (data, width, height, level) => {
                if (level === 0) return data;
                const newData = new Uint8ClampedArray(data);
                
                const getPixel = (i) => {
                   if(i < 0 || i >= data.length) return null;
                   return { r: data[i], g: data[i+1], b: data[i+2], a: data[i+3] };
                };
                
                const isEqual = (p1, p2) => {
                    if(!p1 || !p2) return false;
                    if(p1.a < 128 && p2.a < 128) return true;
                    if(p1.a >= 128 && p2.a >= 128) {
                        return p1.r===p2.r && p1.g===p2.g && p1.b===p2.b;
                    }
                    return false;
                };

                for(let y=0; y<height; y++) {
                    for(let x=0; x<width; x++) {
                        const i = (y*width+x)*4;
                        const curr = getPixel(i);
                        
                        // Neighbors: N, S, W, E
                        const neighbors = [
                            getPixel(( (y-1)*width + x)*4),
                            getPixel(( (y+1)*width + x)*4),
                            getPixel(( y*width + (x-1))*4),
                            getPixel(( y*width + (x+1))*4)
                        ].filter(Boolean);
                        
                        // Count similar neighbors
                        const similar = neighbors.filter(n => isEqual(curr, n)).length;
                        
                        // If pixel is orphan (0 similar neighbors or just 1 in high mode), replace it
                        if (similar <= (level === 2 ? 1 : 0)) {
                            // Find most common neighbor color
                            // Simple: take top neighbor or left neighbor
                            const replacement = neighbors[0]; 
                            if(replacement) {
                                newData[i] = replacement.r;
                                newData[i+1] = replacement.g;
                                newData[i+2] = replacement.b;
                                newData[i+3] = replacement.a;
                            }
                        }
                    }
                }
                return newData;
            };

            // Process Image
            useEffect(() => {
                if (!srcImage) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                // 1. Resize & Draw
                const aspect = srcImage.height / srcImage.width;
                const h = Math.round(width * aspect);
                canvas.width = width;
                canvas.height = h;
                ctx.drawImage(srcImage, 0, 0, width, h);
                
                const imageData = ctx.getImageData(0, 0, width, h);
                let data = imageData.data;

                // 2. Auto-Enhance (Saturation Boost)
                if (autoEnhance) {
                    for(let i=0; i<data.length; i+=4) {
                        // Convert to HSL, boost S, convert back
                        const hex = rgbToHex(data[i], data[i+1], data[i+2]);
                        const hsl = hexToHSL(hex);
                        hsl.s = Math.min(100, hsl.s * 1.3); // Boost saturation by 30%
                        const newHex = hslToHex(hsl.h, hsl.s, hsl.l);
                        const newRgb = hexToRgb(newHex);
                        if(newRgb) {
                            data[i] = newRgb.r;
                            data[i+1] = newRgb.g;
                            data[i+2] = newRgb.b;
                        }
                    }
                }

                // 3. Prepare Palette
                let paletteRGB = [];
                if (conversionMode === 'smart') {
                    paletteRGB = generateSmartPalette(imageData, baseColorCount, shadesPerColor);
                } else if (conversionMode === 'palette') {
                    const allColors = savedPalettes.flatMap(p => p.colors);
                    paletteRGB = allColors.length > 0 ? allColors.map(hexToRgb).filter(c=>c).map(c=>[c.r, c.g, c.b]) : [[0,0,0],[255,255,255]];
                } else if (conversionMode === 'gameboy') {
                    paletteRGB = [[15, 56, 15], [48, 98, 48], [139, 172, 15], [155, 188, 15]];
                } else if (conversionMode === 'mono') {
                    paletteRGB = [[0,0,0], [255,255,255]];
                }

                const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                const bayerMatrix = [[0, 8, 2, 10],[12, 4, 14, 6],[3, 11, 1, 9],[15, 7, 13, 5]];

                // 4. Quantization Loop
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        if(data[i+3] < 128) { data[i+3] = 0; continue; } 

                        let oldR = applyContrast(data[i], contrastFactor);
                        let oldG = applyContrast(data[i+1], contrastFactor);
                        let oldB = applyContrast(data[i+2], contrastFactor);

                        let ditherOffset = 0;
                        if (ditherMode === 'bayer') {
                            const threshold = bayerMatrix[y % 4][x % 4]; 
                            ditherOffset = (threshold - 8) * 4; 
                        }

                        let r = Math.max(0, Math.min(255, oldR + ditherOffset));
                        let g = Math.max(0, Math.min(255, oldG + ditherOffset));
                        let b = Math.max(0, Math.min(255, oldB + ditherOffset));

                        let newColor;
                        if (conversionMode === 'posterize') {
                            const step = 255 / (colorDepth - 1);
                            newColor = [Math.round(r/step)*step, Math.round(g/step)*step, Math.round(b/step)*step];
                        } else {
                            newColor = findClosest(r, g, b, paletteRGB);
                        }

                        if (newColor) {
                            data[i] = newColor[0];
                            data[i+1] = newColor[1];
                            data[i+2] = newColor[2];
                            data[i+3] = 255; 
                        }
                    }
                }

                // 5. Cleanup Pass
                if (cleanupLevel > 0) {
                    data = cleanNoise(data, width, h, cleanupLevel);
                    for(let i=0; i<data.length; i++) imageData.data[i] = data[i];
                }

                // 6. Outline Pass
                if (outlineMode !== 'none') {
                    const originalData = new Uint8ClampedArray(data); // Copy state before outline
                    const isTrans = (x, y) => {
                        if (x<0 || x>=width || y<0 || y>=h) return true;
                        return originalData[(y*width+x)*4 + 3] < 128;
                    };
                    const getPixel = (x, y) => {
                         if (x<0 || x>=width || y<0 || y>=h) return null;
                         const i = (y*width+x)*4;
                         return {r:originalData[i], g:originalData[i+1], b:originalData[i+2]};
                    }

                    for(let y=0; y<h; y++) {
                        for(let x=0; x<width; x++) {
                            const i = (y*width+x)*4;
                            if (originalData[i+3] < 128) continue; 

                            let isEdge = false;
                            if (outlineMode === 'silhouette') {
                                if (isTrans(x, y-1) || isTrans(x, y+1) || isTrans(x-1, y) || isTrans(x+1, y)) isEdge = true;
                            }
                            else if (outlineMode === 'internal') {
                                const curr = getPixel(x, y);
                                const right = getPixel(x+1, y);
                                const bottom = getPixel(x, y+1);
                                const diff = (c1, c2) => (!c1 || !c2) ? 0 : Math.abs(c1.r-c2.r) + Math.abs(c1.g-c2.g) + Math.abs(c1.b-c2.b);

                                if (diff(curr, right) > edgeThreshold || diff(curr, bottom) > edgeThreshold) isEdge = true;
                                if (isTrans(x, y-1) || isTrans(x, y+1) || isTrans(x-1, y) || isTrans(x+1, y)) isEdge = true;
                            }

                            if (isEdge) {
                                let edgeColor = [0,0,0]; 
                                if (outlineColorMode === 'darker') edgeColor = darkenColor(data[i], data[i+1], data[i+2], 0.5);
                                data[i] = edgeColor[0]; data[i+1] = edgeColor[1]; data[i+2] = edgeColor[2]; data[i+3] = 255;
                            }
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                setCombinedUrl(canvas.toDataURL());

            }, [srcImage, width, colorDepth, baseColorCount, shadesPerColor, conversionMode, ditherMode, contrast, savedPalettes, outlineMode, outlineColorMode, edgeThreshold, cleanupLevel, autoEnhance]);

            const handleSend = () => {
                if (!canvasRef.current) return;
                const ctx = canvasRef.current.getContext('2d');
                const w = canvasRef.current.width;
                const h = canvasRef.current.height;
                const imageData = ctx.getImageData(0, 0, w, h);
                const data = imageData.data;
                
                const usedColors = new Set();
                const newPixels = {};
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const i = (y * w + x) * 4;
                        if (data[i+3] > 128) { 
                            const hex = rgbToHex(data[i], data[i+1], data[i+2]);
                            newPixels[`${x},${y}`] = hex;
                            usedColors.add(hex);
                        }
                    }
                }
                
                if (conversionMode === 'smart' && usedColors.size > 0) {
                    setSavedPalettes([{
                        id: Date.now(),
                        colors: Array.from(usedColors),
                        base: 'Imported'
                    }, ...savedPalettes]);
                }

                onSendToEditor(newPixels, w);
            };

            const handleDownload = (url) => {
                if (url) {
                    const link = document.createElement('a');
                    link.download = `pixel-art-result-${Date.now()}.png`;
                    link.href = url;
                    link.click();
                }
            };

            return (
                <div className="flex flex-col h-full p-4 md:p-8 gap-6 items-center overflow-y-auto">
                    <div className="bg-[#1f2937] p-6 rounded-3xl border border-gray-700 shadow-2xl w-full max-w-5xl flex flex-col gap-6">
                        <h2 className="text-2xl font-bold text-white flex items-center gap-2"><ScanEye size={24} className="text-purple-400"/> Chuyển Ảnh Sang Pixel Art</h2>
                        
                        <div className="grid md:grid-cols-2 gap-6">
                            {/* Left: Input & Controls */}
                            <div className="flex flex-col gap-4">
                                <div className="relative border-2 border-dashed border-gray-600 rounded-xl p-6 text-center hover:border-blue-500 transition bg-black/20">
                                    <input type="file" accept="image/*" onChange={handleImageUpload} className="absolute inset-0 opacity-0 cursor-pointer"/>
                                    <div className="flex flex-col items-center gap-2">
                                        <div className="p-3 bg-gray-800 rounded-full text-blue-400"><ImageIcon size={32}/></div>
                                        <p className="text-gray-300 font-bold">Tải Ảnh Gốc</p>
                                    </div>
                                </div>

                                {srcImage && (
                                    <div className="space-y-4 bg-gray-800/30 p-4 rounded-xl border border-gray-700 text-sm">
                                        {/* Size */}
                                        <div>
                                            <div className="flex justify-between mb-1 text-gray-400"><span>Kích thước (Width)</span><span className="text-blue-400">{width}px</span></div>
                                            <input type="range" min="16" max="200" value={width} onChange={(e)=>setWidth(Number(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg accent-blue-500"/>
                                        </div>
                                        
                                        {/* Enhancements */}
                                        <div className="grid grid-cols-2 gap-2">
                                            <label className="flex items-center gap-2 cursor-pointer bg-black/20 p-2 rounded border border-gray-700 hover:border-gray-500">
                                                <input type="checkbox" checked={autoEnhance} onChange={(e)=>setAutoEnhance(e.target.checked)} className="rounded text-blue-500 focus:ring-0"/>
                                                <span className="text-xs text-gray-300"><Wand2 size={12} className="inline mr-1"/>Auto Đẹp</span>
                                            </label>
                                            <label className="flex items-center gap-2 cursor-pointer bg-black/20 p-2 rounded border border-gray-700 hover:border-gray-500">
                                                <span className="text-xs text-gray-300">Khử Nhiễu:</span>
                                                <select value={cleanupLevel} onChange={(e)=>setCleanupLevel(Number(e.target.value))} className="bg-transparent text-green-400 text-xs font-bold focus:outline-none">
                                                    <option value="0">Tắt</option>
                                                    <option value="1">Thấp</option>
                                                    <option value="2">Cao</option>
                                                </select>
                                            </label>
                                        </div>

                                        {/* Color Mode */}
                                        <div>
                                            <label className="text-gray-400 block mb-2 font-bold uppercase text-xs">Màu Sắc</label>
                                            <div className="grid grid-cols-2 gap-2 mb-2">
                                                <button onClick={()=>setConversionMode('smart')} className={`py-1.5 rounded border text-xs ${conversionMode==='smart'?'bg-blue-600 border-blue-500':'border-gray-600 text-gray-400'}`}>Smart AI</button>
                                                <button onClick={()=>setConversionMode('palette')} className={`py-1.5 rounded border text-xs ${conversionMode==='palette'?'bg-blue-600 border-blue-500':'border-gray-600 text-gray-400'}`}>Palette</button>
                                            </div>
                                            
                                            {conversionMode === 'smart' && (
                                                <div className="grid grid-cols-2 gap-2">
                                                    <div>
                                                        <span className="text-xs text-gray-500 block">Nhóm màu</span>
                                                        <input type="number" min="2" max="16" value={baseColorCount} onChange={(e)=>setBaseColorCount(Number(e.target.value))} className="w-full bg-gray-900 border border-gray-600 rounded px-2 py-1 text-xs"/>
                                                    </div>
                                                    <div>
                                                        <span className="text-xs text-gray-500 block">Sắc độ</span>
                                                        <input type="number" min="1" max="8" value={shadesPerColor} onChange={(e)=>setShadesPerColor(Number(e.target.value))} className="w-full bg-gray-900 border border-gray-600 rounded px-2 py-1 text-xs"/>
                                                    </div>
                                                </div>
                                            )}
                                        </div>

                                        {/* Outline Settings */}
                                        <div className="border-t border-gray-700 pt-4">
                                            <label className="text-gray-400 block mb-2 font-bold uppercase text-xs flex justify-between">
                                                Viền (Outline)
                                                <span className="text-xs text-green-400">{outlineMode === 'none' ? 'Tắt' : (outlineMode === 'silhouette' ? 'Viền Ngoài' : 'Nội Bộ')}</span>
                                            </label>
                                            <div className="flex gap-2 mb-2">
                                                <button onClick={()=>setOutlineMode('none')} className={`flex-1 py-1 text-xs rounded border ${outlineMode==='none'?'bg-gray-600 text-white':'border-gray-600 text-gray-500'}`}>Không</button>
                                                <button onClick={()=>setOutlineMode('silhouette')} className={`flex-1 py-1 text-xs rounded border ${outlineMode==='silhouette'?'bg-blue-600 text-white':'border-gray-600 text-gray-500'}`}>Ngoài</button>
                                                <button onClick={()=>setOutlineMode('internal')} className={`flex-1 py-1 text-xs rounded border ${outlineMode==='internal'?'bg-blue-600 text-white':'border-gray-600 text-gray-500'}`}>Cả Trong</button>
                                            </div>
                                            
                                            {outlineMode === 'internal' && (
                                                <div className="mb-2">
                                                    <div className="flex justify-between text-xs text-gray-400"><span>Độ Nhạy Viền</span><span>{edgeThreshold}</span></div>
                                                    <input type="range" min="10" max="100" value={edgeThreshold} onChange={(e)=>setEdgeThreshold(Number(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg accent-blue-500"/>
                                                </div>
                                            )}

                                            {outlineMode !== 'none' && (
                                                <div className="flex gap-2">
                                                    <button onClick={()=>setOutlineColorMode('black')} className={`flex-1 py-1 text-xs rounded border ${outlineColorMode==='black'?'bg-black text-white border-gray-500':'border-gray-600 text-gray-500'}`}>Đen</button>
                                                    <button onClick={()=>setOutlineColorMode('darker')} className={`flex-1 py-1 text-xs rounded border ${outlineColorMode==='darker'?'bg-purple-900 text-white border-purple-500':'border-gray-600 text-gray-500'}`}>Đậm Hơn</button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>

                            {/* Right: Result Preview */}
                            <div className="flex flex-col gap-4">
                                <div className="relative bg-black/40 p-4 rounded-xl border border-gray-700 h-[400px] flex items-center justify-center overflow-hidden group">
                                    <span className="absolute top-3 left-3 text-xs text-gray-500 uppercase font-bold z-10 bg-black/50 px-2 py-1 rounded">Kết Quả</span>
                                    <canvas ref={canvasRef} className="hidden"/> 
                                    {combinedUrl ? (
                                        <img src={combinedUrl} style={{imageRendering: 'pixelated', transform: `scale(${previewScale})`, maxWidth: '100%', maxHeight: '100%', transition: 'transform 0.1s'}} />
                                    ) : <span className="text-gray-600 text-sm">Chưa có ảnh</span>}

                                    {/* Zoom Overlay */}
                                    <div className="absolute bottom-4 right-4 flex bg-black/70 rounded-lg backdrop-blur p-1 opacity-0 group-hover:opacity-100 transition">
                                        <button onClick={()=>setPreviewScale(s=>Math.max(0.5, s-0.5))} className="p-2 hover:text-white text-gray-300"><Minus size={16}/></button>
                                        <span className="py-2 text-xs font-mono w-12 text-center">{previewScale}x</span>
                                        <button onClick={()=>setPreviewScale(s=>Math.min(10, s+0.5))} className="p-2 hover:text-white text-gray-300"><Plus size={16}/></button>
                                    </div>
                                </div>

                                <div className="grid grid-cols-2 gap-3">
                                    <button onClick={()=>handleDownload(combinedUrl)} disabled={!srcImage} className="py-3 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-sm flex items-center justify-center gap-2 shadow-lg transition">
                                        <Download size={18}/> Tải Ảnh Về
                                    </button>
                                    <button onClick={handleSend} disabled={!srcImage} className="py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-bold text-sm flex items-center justify-center gap-2 shadow-lg transition">
                                        <ArrowRight size={18}/> Sửa Trong Editor
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Pixel Editor Tab
        const PixelEditor = ({ selectedColor, setSelectedColor, savedPalettes, importData }) => {
            // ... (Keep existing PixelEditor code exactly as is)
            const [size, setSize] = useState(16);
            const [inputSize, setInputSize] = useState(16);
            const [tool, setTool] = useState('pencil');
            const [showGrid, setShowGrid] = useState(true);
            
            const [layers, setLayers] = useState([{ id: 1, name: 'Layer 1', visible: true, pixels: {} }]);
            const [activeLayerId, setActiveLayerId] = useState(1);
            
            const [history, setHistory] = useState([]);
            const [historyStep, setHistoryStep] = useState(-1);
            
            const [scale, setScale] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const isDrawing = useRef(false);
            const isPanning = useRef(false);
            const lastMousePos = useRef({ x: 0, y: 0 });

            useEffect(() => {
                if (importData) {
                    setSize(importData.size);
                    setInputSize(importData.size);
                    setLayers([{ id: 1, name: 'Imported', visible: true, pixels: importData.pixels }]);
                    setActiveLayerId(1);
                    setHistory([]);
                    setHistoryStep(-1);
                    setPan({x:0,y:0});
                    setScale(Math.max(1, Math.floor(400 / importData.size)));
                    
                    setTimeout(() => pushHistory([{ id: 1, name: 'Imported', visible: true, pixels: importData.pixels }], 1), 50);
                }
            }, [importData]);

            useEffect(() => {
                if (historyStep === -1 && !importData) {
                    pushHistory(layers, 1);
                }
            }, []);
            
            const pushHistory = (currentLayers, currentActiveId) => {
                const newHistory = history.slice(0, historyStep + 1);
                const layersClone = JSON.parse(JSON.stringify(currentLayers));
                newHistory.push({ layers: layersClone, activeLayerId: currentActiveId });
                if(newHistory.length > 30) newHistory.shift();
                setHistory(newHistory);
                setHistoryStep(newHistory.length - 1);
                setLayers(layersClone);
            };
            
            const handleUndo = () => {
                if (historyStep > 0) {
                    const prev = history[historyStep - 1];
                    setLayers(prev.layers);
                    setActiveLayerId(prev.activeLayerId);
                    setHistoryStep(historyStep - 1);
                }
            };

            const getCoords = (clientX, clientY) => {
                if (!canvasRef.current) return {x:0, y:0};
                const rect = canvasRef.current.getBoundingClientRect();
                const x = Math.floor((clientX - rect.left) / (rect.width / size));
                const y = Math.floor((clientY - rect.top) / (rect.height / size));
                return { x, y };
            };

            const paintPixel = (x, y, targetLayers) => {
                if (x < 0 || x >= size || y < 0 || y >= size) return;
                const key = `${x},${y}`;
                const layerIndex = targetLayers.findIndex(l => l.id === activeLayerId);
                if (layerIndex === -1 || !targetLayers[layerIndex].visible) return;

                if (tool === 'pencil') {
                    targetLayers[layerIndex].pixels[key] = selectedColor;
                } else if (tool === 'eraser') {
                    delete targetLayers[layerIndex].pixels[key];
                }
            };

            const floodFill = (startX, startY, currentLayers) => {
                const layerIndex = currentLayers.findIndex(l => l.id === activeLayerId);
                if (layerIndex === -1 || !currentLayers[layerIndex].visible) return currentLayers;

                const pixels = currentLayers[layerIndex].pixels;
                const key = `${startX},${startY}`;
                const targetColor = pixels[key];
                if (targetColor === selectedColor) return currentLayers;

                const newLayers = JSON.parse(JSON.stringify(currentLayers));
                const newPixels = newLayers[layerIndex].pixels;
                const stack = [[startX, startY]];
                
                while (stack.length) {
                    const [x, y] = stack.pop();
                    const k = `${x},${y}`;
                    if (x < 0 || x >= size || y < 0 || y >= size) continue;
                    
                    if (newPixels[k] === targetColor) {
                        newPixels[k] = selectedColor;
                        stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                    }
                }
                return newLayers;
            };

            const handlePointerDown = (e) => {
                if (e.button === 1 || (e.button === 0 && e.getModifierState && e.getModifierState('Space'))) {
                    isPanning.current = true;
                    lastMousePos.current = { x: e.clientX, y: e.clientY };
                    return;
                }
                if(e.button !== 0) return;
                const { x, y } = getCoords(e.clientX, e.clientY);
                if (tool === 'picker') {
                    for (let i = layers.length - 1; i >= 0; i--) {
                        if (layers[i].visible && layers[i].pixels[`${x},${y}`]) {
                            setSelectedColor(layers[i].pixels[`${x},${y}`]);
                            setTool('pencil');
                            return;
                        }
                    }
                    return;
                }
                if (tool === 'fill') {
                    const newLayers = floodFill(x, y, layers);
                    pushHistory(newLayers, activeLayerId);
                    return;
                }
                isDrawing.current = true;
                const newLayers = JSON.parse(JSON.stringify(layers));
                paintPixel(x, y, newLayers);
                setLayers(newLayers);
            };

            const handlePointerMove = (e) => {
                if (isPanning.current) {
                    const dx = e.clientX - lastMousePos.current.x;
                    const dy = e.clientY - lastMousePos.current.y;
                    setPan(p => ({ x: p.x + dx, y: p.y + dy }));
                    lastMousePos.current = { x: e.clientX, y: e.clientY };
                    return;
                }
                if (!isDrawing.current) return;
                const { x, y } = getCoords(e.clientX, e.clientY);
                setLayers(prev => {
                    const next = JSON.parse(JSON.stringify(prev));
                    paintPixel(x, y, next);
                    return next;
                });
            };

            const handlePointerUp = () => {
                if (isPanning.current) {
                    isPanning.current = false;
                    return;
                }
                if (isDrawing.current) {
                    isDrawing.current = false;
                    pushHistory(layers, activeLayerId);
                }
            };

            const handleWheel = (e) => {
                if (!containerRef.current) return;
                e.preventDefault();
                const rect = containerRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const zoomIntensity = 0.1;
                const delta = e.deltaY < 0 ? 1 : -1;
                const newScale = Math.max(0.1, Math.min(50, scale * (1 + delta * zoomIntensity)));
                const scaleFactor = newScale / scale;
                const newPanX = mouseX - (mouseX - pan.x) * scaleFactor;
                const newPanY = mouseY - (mouseY - pan.y) * scaleFactor;
                setScale(newScale);
                setPan({ x: newPanX, y: newPanY });
            };

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, size, size);
                layers.forEach(layer => {
                    if (!layer.visible) return;
                    for (let key in layer.pixels) {
                        const [x, y] = key.split(',').map(Number);
                        ctx.fillStyle = layer.pixels[key];
                        ctx.fillRect(x, y, 1, 1);
                    }
                });
                if (showGrid && size <= 100) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.lineWidth = 0.02;
                    ctx.beginPath();
                    for (let i = 0; i <= size; i++) {
                        ctx.moveTo(i, 0); ctx.lineTo(i, size);
                        ctx.moveTo(0, i); ctx.lineTo(size, i);
                    }
                    ctx.stroke();
                }
            }, [layers, size, showGrid]);

            const addLayer = () => {
                const newId = Date.now();
                const newLayer = { id: newId, name: `Layer ${layers.length + 1}`, visible: true, pixels: {} };
                const newLayers = [...layers, newLayer];
                pushHistory(newLayers, newId);
            };
            const deleteLayer = (id) => {
                if (layers.length <= 1) return;
                const newLayers = layers.filter(l => l.id !== id);
                pushHistory(newLayers, newLayers[newLayers.length - 1].id);
            };
            const toggleLayer = (id) => {
                const newLayers = layers.map(l => l.id === id ? { ...l, visible: !l.visible } : l);
                setLayers(newLayers);
            };
            const changeSize = () => {
                const s = parseInt(inputSize);
                if (s > 0 && s <= 500) {
                    if (confirm("Đổi kích thước sẽ xóa bản vẽ hiện tại?")) {
                        setSize(s);
                        setLayers([{ id: 1, name: 'Layer 1', visible: true, pixels: {} }]);
                        setActiveLayerId(1);
                        setHistory([]);
                        setHistoryStep(-1);
                        setPan({x:0, y:0});
                        setScale(1);
                        setTimeout(() => pushHistory([{ id: 1, name: 'Layer 1', visible: true, pixels: {} }], 1), 50);
                    }
                } else {
                    alert("Kích thước từ 1 - 500");
                }
            };
            const exportImage = (scale = 1) => {
                const canvas = document.createElement('canvas');
                canvas.width = size * scale;
                canvas.height = size * scale;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                layers.forEach(layer => {
                    if (!layer.visible) return;
                    for (let key in layer.pixels) {
                        const [x, y] = key.split(',').map(Number);
                        ctx.fillStyle = layer.pixels[key];
                        ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                });
                const link = document.createElement('a');
                link.download = `pixel-art-${size}x${size}.png`;
                link.href = canvas.toDataURL();
                link.click();
            };

            return (
                <div className="flex flex-col lg:flex-row h-full overflow-hidden">
                    <div className="w-full lg:w-16 bg-[#1f2937] border-r border-gray-700 flex lg:flex-col items-center p-2 gap-2 overflow-x-auto lg:overflow-visible shrink-0 z-10">
                        {[
                            { id: 'pencil', icon: <PenTool size={20}/>, label: 'Bút' },
                            { id: 'eraser', icon: <Eraser size={20}/>, label: 'Tẩy' },
                            { id: 'fill', icon: <PaintBucket size={20}/>, label: 'Đổ màu' },
                            { id: 'picker', icon: <Droplet size={20}/>, label: 'Hút màu' },
                        ].map(t => (
                            <button key={t.id} onClick={() => setTool(t.id)} className={`p-3 rounded-xl transition ${tool === t.id ? 'bg-blue-600 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>
                                {t.icon}
                            </button>
                        ))}
                        <div className="w-px h-8 lg:w-8 lg:h-px bg-gray-700 my-1"></div>
                        <button onClick={handleUndo} className="p-3 rounded-xl bg-gray-800 text-gray-400 hover:text-white"><Undo size={20}/></button>
                        <button onClick={()=>pushHistory(layers.map(l=>l.id===activeLayerId ? {...l, pixels:{}} : l), activeLayerId)} className="p-3 rounded-xl bg-gray-800 text-gray-400 hover:text-red-500"><Trash2 size={20}/></button>
                        <div className="flex-1 lg:h-full"></div>
                        <div className="w-8 h-8 rounded-full border-2 border-white" style={{backgroundColor: selectedColor}}></div>
                    </div>

                    <div className="flex-1 bg-[#111827] relative overflow-hidden flex flex-col" ref={containerRef}>
                        <div className="h-12 bg-[#1f2937] border-b border-gray-700 flex items-center px-4 justify-between shrink-0 z-10">
                            <div className="flex items-center gap-2">
                                <input type="number" value={inputSize} onChange={e=>setInputSize(e.target.value)} className="w-16 bg-gray-800 border border-gray-600 rounded px-2 py-1 text-xs text-white"/>
                                <button onClick={changeSize} className="px-3 py-1 bg-blue-600 text-xs rounded font-bold hover:bg-blue-500">Set Size</button>
                                <span className="text-gray-500 text-xs ml-2">{size}x{size}</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <button onClick={()=>setShowGrid(!showGrid)} className={`p-2 rounded ${showGrid ? 'text-blue-400' : 'text-gray-400'}`}><GridIcon size={16}/></button>
                                <button onClick={()=>exportImage(size < 32 ? 20 : (size < 100 ? 10 : 2))} className="p-2 rounded text-green-400"><Download size={16}/></button>
                            </div>
                        </div>

                        <div 
                            className="flex-1 relative overflow-hidden checkered-bg cursor-move"
                            onWheel={handleWheel}
                            onPointerDown={handlePointerDown}
                            onPointerMove={handlePointerMove}
                            onPointerUp={handlePointerUp}
                            onPointerLeave={handlePointerUp}
                        >
                            <div style={{
                                transform: `translate(${pan.x}px, ${pan.y}px) scale(${scale})`,
                                transformOrigin: '0 0',
                                width: '100%', height: '100%',
                                display: 'flex', alignItems: 'center', justifyContent: 'center'
                            }}>
                                <canvas
                                    ref={canvasRef}
                                    width={size}
                                    height={size}
                                    className="bg-transparent shadow-2xl"
                                    style={{
                                        width: size, 
                                        height: size, 
                                        border: '1px solid rgba(255,255,255,0.1)',
                                    }}
                                />
                            </div>
                        </div>
                    </div>

                    <div className="w-full lg:w-64 bg-[#1f2937] border-l border-gray-700 flex flex-col h-1/3 lg:h-full shrink-0 z-10">
                        <div className="flex-1 flex flex-col border-b border-gray-700 min-h-0">
                            <div className="p-2 bg-gray-800 font-bold text-xs text-gray-400 uppercase flex justify-between items-center">
                                <div className="flex items-center gap-2"><LayersIcon size={14}/> Layers</div>
                                <button onClick={addLayer} className="hover:text-white"><Plus size={14}/></button>
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-1">
                                {[...layers].reverse().map(l => (
                                    <div 
                                        key={l.id} 
                                        onClick={()=>setActiveLayerId(l.id)}
                                        className={`flex items-center gap-2 p-2 rounded cursor-pointer ${activeLayerId === l.id ? 'bg-blue-600 text-white' : 'hover:bg-gray-700 text-gray-300'}`}
                                    >
                                        <button onClick={(e)=>{e.stopPropagation(); toggleLayer(l.id)}} className="hover:text-gray-100">
                                            {l.visible ? <Eye size={14}/> : <EyeOff size={14}/>}
                                        </button>
                                        <span className="flex-1 text-xs truncate">{l.name}</span>
                                        <button onClick={(e)=>{e.stopPropagation(); deleteLayer(l.id)}} className="text-gray-500 hover:text-red-300"><Trash2 size={12}/></button>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="h-1/2 flex flex-col">
                            <div className="p-2 bg-gray-800 font-bold text-xs text-gray-400 uppercase flex items-center gap-2">
                                <PaletteIcon size={14}/> Palette
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 content-start">
                                <div className="flex flex-wrap gap-1">
                                    {savedPalettes.flatMap(p => p.colors).map((c, i) => (
                                        <button 
                                            key={i} 
                                            onClick={() => setSelectedColor(c)}
                                            className={`w-6 h-6 rounded border border-gray-600 ${selectedColor === c ? 'ring-2 ring-white z-10' : ''}`}
                                            style={{backgroundColor: c}}
                                        />
                                    ))}
                                    {/* Default Colors */}
                                    {['#000000', '#ffffff', '#ef4444', '#22c55e', '#3b82f6', '#eab308'].map(c => (
                                        <button key={c} onClick={()=>setSelectedColor(c)} className="w-6 h-6 rounded border border-gray-600" style={{backgroundColor:c}}/>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        function App() {
            const [view, setView] = useState('editor');
            const [savedPalettes, setSavedPalettes] = useState(() => {
                const saved = localStorage.getItem('pixelPalettes');
                return saved ? JSON.parse(saved) : [];
            });
            const [selectedColor, setSelectedColor] = useState('#3b82f6');
            const [importData, setImportData] = useState(null);

            useEffect(() => {
                localStorage.setItem('pixelPalettes', JSON.stringify(savedPalettes));
            }, [savedPalettes]);

            const handleImport = (pixels, size) => {
                setImportData({ pixels, size });
                setView('editor');
            };

            return (
                <div className="h-screen flex flex-col bg-[#111827] text-white">
                    <nav className="h-10 border-b border-gray-700 flex items-center px-4 justify-between bg-[#1f2937] shrink-0 z-50 text-xs">
                        <div className="font-pixel text-blue-400">Pixel Studio Pro</div>
                        <div className="flex gap-4">
                            <button onClick={() => setView('generator')} className={view==='generator'?'text-white font-bold':'text-gray-400'}>Palette</button>
                            <button onClick={() => setView('converter')} className={view==='converter'?'text-white font-bold':'text-gray-400'}>Converter</button>
                            <button onClick={() => setView('editor')} className={view==='editor'?'text-white font-bold':'text-gray-400'}>Editor</button>
                        </div>
                    </nav>
                    <div className="flex-1 overflow-hidden relative">
                        {view === 'generator' ? (
                            <PaletteGenerator savedPalettes={savedPalettes} setSavedPalettes={setSavedPalettes} onSelectColor={setSelectedColor} />
                        ) : view === 'converter' ? (
                            <PixelConverter onSendToEditor={handleImport} savedPalettes={savedPalettes} setSavedPalettes={setSavedPalettes} />
                        ) : (
                            <PixelEditor 
                                selectedColor={selectedColor} 
                                setSelectedColor={setSelectedColor} 
                                savedPalettes={savedPalettes}
                                importData={importData}
                            />
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
